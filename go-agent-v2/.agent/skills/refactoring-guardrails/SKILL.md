---
name: refactoring-guardrails
description: 在进行代码重构、函数拆分、抽取公共逻辑/基类/接口、重排文件或需要护栏与回归保障以保持行为一致时使用。
---

# 重构护栏 (Refactoring Guardrails)

## 概述

为高风险重构提供“护栏 + 对比 + 回归”的最小流程，确保行为一致、回归可观测、可回滚。

## 必需子技能

- **后端**：涉及 Go 后端/引擎代码时，先加载后端规范再执行。
- **测试驱动开发**：重构必须遵循先失败测试的 TDD 循环。
- **Git 原子提交**：重构动作原子化，禁止一次提交 1000+ 行修改。

---

## 重构判断标准 (经典规范)

### Code Smells 速查 (Martin Fowler)

> 📚 **来源**: 《重构：改善既有代码的设计》

| 坏味道 | 信号 | Agent 行动 |
|--------|------|-----------|
| **重复代码** | 3+ 处相似结构 | 提取工厂函数/泛型 |
| **过长函数** | >50 行 | 拆分为子函数 |
| **过大的类** | >500 行或 >10 方法 | 拆分职责 |
| **依恋情节** | 过度调用外部类方法 | 移动方法到目标类 |
| **数据泥团** | 多个参数总是一起出现 | 提取为结构体 |
| **夸夸其谈未来性** | TODO/未使用的抽象 | 删除 (YAGNI) |
| **过长参数列表** | >5 个参数 | Options 模式 |
| **发散式变化** | 一个类因多种原因修改 | 拆分职责 |
| **霰弹式修改** | 一个变化影响多个类 | 合并相关逻辑 |

### SOLID 原则验收 (Uncle Bob)

重构完成后必须满足：

| 原则 | 检查项 | 违反信号 |
|------|--------|---------|
| **S** 单一职责 | 类/函数只做一件事 | 函数名含 And/Or |
| **O** 开闭原则 | 新增功能通过扩展非修改 | 每次新增都改核心代码 |
| **L** 里氏替换 | 子类可完全替换父类 | 子类覆盖后行为不兼容 |
| **I** 接口隔离 | 接口最小化 (1-3 方法) | 实现类有空方法 |
| **D** 依赖倒置 | 依赖抽象非具体 | import 具体实现包 |

### 工程军规

| 军规 | 内容 | 实践 |
|------|------|------|
| **童子军** | 离开时让代码比发现时更干净 | 顺手修复小问题 |
| **迪米特** | 对象应对其他对象知道得最少 | 消灭 `a.B().C().Do()` |
| **YAGNI** | 你以后才用的东西现在别写 | TODO → WONTFIX |
| **DRY** | 不要重复自己 | 3+ 重复 → 抽象 |
| **微小提交** | 重构动作原子化 (Google) | 单次 <300 行，禁止 1000+ 行 |

---

## 触发条件 / 非触发

**使用此技能：**
- 重构/拆分大函数、抽取公共逻辑、引入基类或接口
- 并发逻辑、状态机、交易/风控计算、WebSocket/网络链路调整
- 行为一致性必须可验证或需要回归可观测性

**一般不需要：**
- 仅注释、格式化、纯重命名（且无行为变化）
- 仅移动文件且无逻辑改动（仍建议跑基础回归）

## 风险分级（决定是否启用护栏流程）

**高风险（必须启用护栏流程）：**
- 业务行为、并发/时序、状态迁移、交易/撮合/风控、外部协议交互

**中风险（建议启用护栏流程）：**
- 抽象层次变化（基类/接口化）、跨包逻辑合并、共享工具函数

**低风险（可简化流程）：**
- 纯文件拆分、局部重命名、纯内联/提取小函数

## 核心流程（高风险必做）

0. **补充回归测试**：为本次重构建立回归用例，确保“变化可观测”。
1. **补护栏**：新旧逻辑双跑/双算/影子执行，输出一致性对比。
2. **纯文件拆分**：先做结构调整，不改逻辑。
3. **实际功能拆分**：开始抽象/合并/改逻辑，对比护栏输出。
4. **一致性对比通过后拆除护栏**：保留最小必要校验与日志。
5. **进行回归测试**：最终结果与原测试一致才通过。

## 护栏实现要点

- **双跑/影子执行**：同输入同时走新旧路径，结果做 diff。
- **对比粒度**：关键输出、关键状态、关键副作用（订单/仓位/余额/事件）。
- **允许阈值**：数值比较需定义误差阈值（如浮点/Decimal）。
- **对比可观测**：日志字段固定、差异可定位（带 request/id/trace）。
- **护栏可开关**：通过配置/编译标志开启，便于分阶段启用/回滚。

## 拆分策略

- **纯文件拆分**：只移动代码位置，不改逻辑；确保编译与基础测试过。
- **实际功能拆分**：引入新抽象/合并逻辑；通过护栏对比保证一致。

### 🚫 Anti-Chains 禁令

> [!CAUTION]
> **禁止创建 `_chains.go` 文件，禁止拆分超过 3 层！**

| 限制 | 阈值 | 说明 |
|------|------|------|
| `_chains.go` 后缀 | **禁止** | 此模式已造成 349 个碎片文件 |
| 文件名语义层深度 | **≤3 层** | 如 `order_validate_price.go` 是上限 |
| 单文件最小行数 | **≥50 行** | 低于 50 行应合并到父文件 |
| 同包文件数上限 | **≤15 个** | 超过则提取子包或合并碎片 |

**拆分时检查**：
- 拆出的新文件是否 ≥50 行？否则不拆
- 文件名是否超过 3 层语义？否则精简命名
- 整个目录的 `.go` 文件是否 >15 个？否则考虑合并

## 一致性对比清单

- **返回值**：结构体字段、状态码、错误类型
- **副作用**：写库、发单、更新缓存/状态机
- **时序**：并发顺序、重试/超时边界
- **性能**：关键路径延迟不回退（以基线为准）

## 回滚与拆除护栏

- **回滚条件**：护栏差异超阈值或回归失败
- **拆除条件**：护栏差异为 0（或低于阈值）并持续稳定一段时间
- **拆除动作**：移除双跑逻辑，仅保留必要的日志/指标

## 快速检查清单

- [ ] 有失败的回归测试（TDD 红色）
- [ ] 护栏双跑已接入且可开关
- [ ] 纯拆分完成且无行为改动
- [ ] 护栏一致性对比通过
- [ ] 拆除护栏后仍通过全量回归

## 示例（Go 伪代码）

```go
// 双跑对比（示意）
func (s *Service) calcWithGuardrail(ctx context.Context, in Input) (Output, error) {
    oldOut, oldErr := s.calcLegacy(ctx, in)
    newOut, newErr := s.calcNew(ctx, in)

    if diff := compareOutput(oldOut, newOut, oldErr, newErr); diff != nil {
        logger.Warn("guardrail_diff", "diff", diff, "id", in.ID)
        return oldOut, oldErr // 影子执行：返回旧结果
    }
    return newOut, newErr
}
```

## 常见错误

- 直接改逻辑不加护栏，导致差异不可回溯
- 只比较日志/文字，未比较关键状态/副作用
- 护栏一直保留不拆除，长期成本过高
- 没有独立回归用例，变化不可观测
