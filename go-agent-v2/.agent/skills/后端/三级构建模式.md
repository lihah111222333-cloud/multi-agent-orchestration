---
name: 三级构建模式
description: 需要区分生产/开发/调试环境行为、配置日志级别、或添加仅调试代码时使用
aliases: ["@构建模式", "@buildmode"]
---

# 三级构建模式 (Build Mode)

## 概述

`pkg/buildmode` 通过 Go build tags 提供编译时三级模式控制。`Mode` 是 `const` 常量，编译器对基于它的条件分支做死代码消除，确保生产二进制不包含调试代码。

## 三种模式

| 模式 | Tag | 命令 | 场景 |
|------|-----|------|------|
| **Release** | _(默认)_ | `go build ./...` | 生产部署 |
| **Dev** | `dev` | `go build -tags=dev ./...` | 本地开发 |
| **Debug** | `debug` | `go build -tags=debug ./...` | 问题排查 |

优先级：`debug` > `dev` > Release（同时传 `dev,debug` 时 Debug 生效）

## 使用方式

```go
import "github.com/quant-trading-system/wjboot/v2/pkg/buildmode"

// 布尔判断（编译器可消除整个分支）
if buildmode.IsDebug() {
    // 仅 debug 构建存在
}
if buildmode.IsDev() {
    // dev + debug 都存在
}

// switch 分支（编译器消除不匹配的 case）
switch buildmode.Mode {
case buildmode.Debug:   // 全量调试
case buildmode.Dev:     // 开发
case buildmode.Release: // 生产
}
```

## 三层日志系统集成

### 现有 logger 模式映射

`pkg/logger` 已有三种模式，与 `buildmode` 对应：

| buildmode | logger.Mode | 日志级别 | Handler | 源码位置 |
|-----------|------------|---------|---------|---------|
| Release | `Production` | Info | JSON → stdout | ❌ |
| Dev | `Development` | Debug | Text → stderr | ✅ |
| Debug | `ModeDebug` | Debug | Text → stderr | ✅ |

### 初始化方式

```go
import (
    "github.com/quant-trading-system/wjboot/v2/pkg/buildmode"
    "github.com/quant-trading-system/wjboot/v2/pkg/logger"
)

func initLogger() {
    switch buildmode.Mode {
    case buildmode.Debug:
        logger.InitMode(logger.ModeDebug)
    case buildmode.Dev:
        logger.InitMode(logger.Development)
    case buildmode.Release:
        logger.InitMode(logger.Production)
    }
}
```

### 日志级别行为

| 级别 | Release | Dev | Debug |
|------|---------|-----|-------|
| `logger.Error()` | ✅ JSON | ✅ Text | ✅ Text |
| `logger.Warn()` | ✅ JSON | ✅ Text | ✅ Text |
| `logger.Info()` | ✅ JSON | ✅ Text | ✅ Text |
| `logger.Debug()` | ❌ 过滤 | ✅ Text | ✅ Text |
| `logger.Debugf()` | ❌ 过滤 | ✅ Text | ✅ Text |
| Source (源码位置) | ❌ | ✅ | ✅ |
| Sampling (采样) | ✅ 启用 | ❌ | ❌ |

### 条件日志（避免无用计算）

```go
// ❌ 坏：即使 release 也会执行 expensiveFormat()
logger.Debug("state", "detail", expensiveFormat(state))

// ✅ 好：release 构建编译器直接消除
if buildmode.IsDev() {
    logger.Debug("state", "detail", expensiveFormat(state))
}
```

## 文件结构

```
pkg/buildmode/
├── mode.go             # BuildMode 类型 + IsDebug()/IsDev()/IsRelease()
├── mode_release.go     # //go:build !dev && !debug → const Mode = Release
├── mode_dev.go         # //go:build dev && !debug  → const Mode = Dev
└── mode_debug.go       # //go:build debug          → const Mode = Debug
```

## 在新模块中使用

### 添加仅调试功能

```go
func (e *Engine) tick() {
    // 核心逻辑（所有模式）
    e.process()

    // 调试模式额外检查
    if buildmode.IsDebug() {
        e.validateState()  // release: 编译器删除
    }
}
```

### 添加开发级日志

```go
func (s *Service) handleRequest(req Request) {
    // 开发 + 调试模式输出请求详情
    if buildmode.IsDev() {
        logger.Debug("request detail",
            "headers", req.Headers,
            "body_size", len(req.Body),
        )
    }
}
```

## 常见错误

| 错误 | 修复 |
|------|------|
| 用 `os.Getenv` 控制调试开关 | 用 `buildmode.IsDebug()`，编译时消除 |
| 为每个功能写 `_debug.go` / `_release.go` | 统一用 `buildmode` const 判断 |
| CI 忘了加 `-tags=debug` 导致测试校验不执行 | Makefile: `test-debug: go test -tags=debug ./...` |
| Logger 模式与 buildmode 不一致 | 启动时按上方模式映射初始化 logger |

## Makefile 推荐配置

```makefile
# 开发
.PHONY: dev
dev:
	go build -tags=dev -o bin/wjboot ./cmd/...

# 调试
.PHONY: debug
debug:
	go build -tags=debug -o bin/wjboot-debug ./cmd/...

# 生产
.PHONY: release
release:
	go build -ldflags="-s -w" -o bin/wjboot ./cmd/...

# 测试（始终 debug 模式，启用所有校验）
.PHONY: test
test:
	go test -tags=debug -count=1 -race ./...
```
