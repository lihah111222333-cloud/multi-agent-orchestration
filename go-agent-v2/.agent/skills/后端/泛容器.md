---
name: SliceMap泛型容器
description: 使用 SliceMap 泛型容器存储 map[K][]V 数据时使用，防止 appendAssign 静默数据丢失 Bug，生产零开销
aliases: ["@SliceMap", "@泛型容器"]
---

# SliceMap 泛型容器使用指南

## 概述

`pkg/collections.SliceMap[K,V]` 封装 `map[K][]V`，将 `append` 回写逻辑封装在方法内部，从类型级别杜绝 appendAssign Bug。三种构建模式下均可使用。

## 何时使用

- 需要 `map[K][]V` 存储历史数据、缓冲区、时间序列时
- 需要滑动窗口（固定长度历史）时
- 需要 append + 自动回写保证，杜绝 appendAssign Bug 时

**不要用于**：固定长度的 map value、非 slice value、性能极致敏感的内联循环（直接用 `GetRef`）

## 核心模式

### 对比：原生 map vs SliceMap

```go
// ❌ 旧：必须记住回写，忘一行就是静默 Bug
type Tracker struct {
    history map[string][]float64
}

func (t *Tracker) Add(key string, val float64) {
    h := append(t.history[key], val)
    if len(h) > t.maxLen {
        h = h[len(h)-t.maxLen:]
    }
    t.history[key] = h  // 忘了这行 = 数据全丢
}

// ✅ 新：不可能忘
type Tracker struct {
    history *collections.SliceMap[string, float64]
}

func (t *Tracker) Add(key string, val float64) {
    t.history.AppendWithLimit(key, t.maxLen, val)
}
```

## 快速参考

| 方法 | 用途 | 性能 |
|------|------|------|
| `Append(key, values...)` | 追加元素，自动回写 | 零开销 |
| `AppendWithLimit(key, max, values...)` | 追加 + 滑动窗口 | 零开销 |
| `GetRef(key)` | 读取内部引用（热路径） | 零拷贝 |
| `Get(key)` | 读取安全副本 | 一次 copy |
| `Len(key)` / `Has(key)` | 查询长度/存在性 | 零开销 |
| `Range(fn)` | 遍历所有 key | — |
| `Set(key, slice)` | 整体替换 | — |
| `Delete(key)` / `Clear()` | 删除/清空 | — |
| `AssertMinLen(key, n)` | 不变量校验（仅 debug） | 生产零开销 |

## 用法速查

1. **字段声明**：`map[K][]V` → `*collections.SliceMap[K, V]`
2. **初始化**：`make(map[K][]V)` → `collections.NewSliceMap[K, V]()`
3. **追加**：`m[k] = append(m[k], v)` → `m.Append(k, v)`
4. **窗口追加**：手动裁剪 → `m.AppendWithLimit(k, maxLen, v)`
5. **读取**：`m[k]` → `m.GetRef(k)` (热路径) 或 `m.Get(k)` (需要副本)
6. **长度**：`len(m[k])` → `m.Len(k)`
7. **删除**：`delete(m, k)` → `m.Delete(k)`

## 三种构建模式

SliceMap 在所有构建模式下行为一致。唯一差异是 `AssertMinLen` / `AssertAllMinLen`：

| 方法 | Release | Dev | Debug |
|------|---------|-----|-------|
| `Append` 等核心方法 | ✅ 正常 | ✅ 正常 | ✅ 正常 |
| `AssertMinLen` | `return nil` | `return nil` | 执行校验 |

```go
// 测试中验证数据增长
for i := 0; i < 100; i++ {
    m.Append("BTC", prices[i])
    if err := m.AssertMinLen("BTC", i+1); err != nil {
        t.Fatal(err) // debug 构建：会校验; release：空操作
    }
}
```

## 常见错误

| 错误 | 修复 |
|------|------|
| 对 `GetRef` 返回值执行 `append` | 用 `Get` 获取副本，或直接调用 `m.Append` |
| 并发访问无锁保护 | SliceMap 本身不加锁，需调用方加 `sync.Mutex` |
| `NewSliceMap` 忘了传类型参数 | Go 泛型需显式：`NewSliceMap[string, float64]()` |

## 已知 map[K][]V 使用点

引擎中使用 `map[K][]V` 的模块（新代码应直接用 SliceMap）：

| 模块 | 字段 | 风险 |
|------|------|------|
| `volatilitysizer` | `priceHistory map[string][]decimal.Decimal` | 高 |
| `slippage_predictor` | `history map[string][]slippageObservation` | 高 |
| `stat_arb` | `PriceHistory map[string][]float64` | 高 |
| `volatility_adaptive` | `priceHistory map[string][]volatilityPricePoint` | 中 |
| `signal_fusion` | `signals []Signal` (filter-in-place) | 低 |
