---
name: 精度漂移不变量
description: 使用精度漂移不变量检测 float64 累积计算与 decimal 精确值之间的误差。三种构建模式均生效。支持指数退避采样（DriftSampler）适配实盘长运行。
tags: [precision, float64, decimal, invariant, backtest, live-trading]
---

# 精度漂移不变量 使用指南

## 触发场景

- 使用 `float64` 做累积计算（均值、ZScore、波动率、PnL）且关心精度
- 长回测中发现结果与预期偏差
- 实盘长运行进程需要持续监控精度

## 核心 API

> 文件: `pkg/collections/precision_invariant.go`

### AssertPrecisionBound — 相对误差（BPS）

```go
// maxDriftBPS = 1.0 表示允许最大 0.01% 偏差
err := collections.AssertPrecisionBound(
    "stat_arb.zscore",     // 标签（用于日志定位）
    zScoreDecimal,         // decimal 精确值
    zScoreFloat64,         // float64 累积值
    1.0,                   // 最大允许漂移（基点 BPS）
)
```

### AssertAbsPrecisionBound — 绝对误差

```go
// 当值接近零时用绝对误差
err := collections.AssertAbsPrecisionBound(
    "funding.rate", rateDecimal, rateFloat64, 0.001)
```

### DriftSampler — 指数退避采样器

```go
// 实盘长运行: 1→2→4→8→16→32→64 分钟，然后回退到 1 重新开始
sampler := collections.NewDriftSampler()

// 在热路径中
if sampler.ShouldCheck() {
    if err := collections.AssertPrecisionBound(...); err != nil {
        logger.Warn("precision drift", "err", err)
    }
}
```

自定义最大间隔：`NewDriftSamplerWithMax(128)` — 最大 128 分钟后回退。

## 三种模式均生效

量化项目中精度问题直接影响收益，因此 **不使用 `buildmode.IsDebug()` 保护**。

| 操作 | 单次开销 |
|------|---------|
| `InexactFloat64()` | ~50ns |
| 除法 + `math.Abs` | ~5ns |
| **合计** | **~55ns** |

对比 K 线处理 ~10-100μs，精度校验开销 < 1%。配合 `DriftSampler` 实盘采样更低。

## 选择策略

| 场景 | API | 采样 |
|------|-----|------|
| 回测（有限 K 线） | 直接调用 | 每次 |
| 实盘（持续运行） | `DriftSampler.ShouldCheck()` | 指数退避 |
| 接近零的值 | `AssertAbsPrecisionBound` | 同上 |

## 使用模式

### 模式 1: 影子对比（最精确）

```go
func (t *PairsTrader) CalculateZScore(a, b string) float64 {
    result := t.calcZScoreFloat(a, b)
    if t.driftSampler.ShouldCheck() {
        _ = collections.AssertPrecisionBound("stat_arb.zscore",
            t.calcZScoreDecimal(a, b), result, 5.0)
    }
    return result
}
```

### 模式 2: 累积值校验

```go
if sampler.ShouldCheck() {
    decSum := decimal.Zero
    floatSum := 0.0
    for _, p := range prices {
        decSum = decSum.Add(decimal.NewFromFloat(p))
        floatSum += p
    }
    _ = collections.AssertPrecisionBound("mean",
        decSum.Div(decimal.NewFromInt(int64(len(prices)))),
        floatSum/float64(len(prices)), 1.0)
}
```

### 模式 3: 单点快速检查

```go
_ = collections.AssertPrecisionBound("order.total",
    order.Price.Mul(order.Quantity), priceFloat*qtyFloat, 0.1)
```

## 推荐阈值

| 场景 | maxDriftBPS | 理由 |
|------|------------|------|
| 价格计算 | 0.1 (0.001%) | 价格精度直接影响订单 |
| ZScore/统计指标 | 5.0 (0.05%) | 统计指标容忍度高 |
| PnL 累积 | 1.0 (0.01%) | 影响最终收益报告 |
| 波动率 | 10.0 (0.1%) | 本身就是估算值 |

## 与其他不变量配合

```go
// 1. 结构完整性 (SliceMap)
s.priceHistory.AppendWithLimit(marketID, windowSize, price)
_ = s.priceHistory.AssertMinLen(marketID, 1)

// 2. 精度完整性 (精度漂移)
_ = collections.AssertPrecisionBound("sizer.price",
    decimalPrice, floatPrice, 0.1)
```
