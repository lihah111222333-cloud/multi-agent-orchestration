---
name: 运行时不变量校验
description: 使用 AssertMinLen/AssertAllMinLen 验证数据一致性、用 buildmode.IsDebug() 添加仅调试校验逻辑时使用，生产构建零开销
aliases: ["@不变量", "@invariant"]
---

# 运行时不变量校验使用指南

## 概述

基于 `pkg/buildmode` 的编译时三级开关，在 Debug 构建中执行运行时数据一致性校验，Release/Dev 构建编译器完全消除校验代码。

## 核心原理

```go
// pkg/buildmode 定义 const Mode
// Release 构建: Mode = 0 (const)
// IsDebug() → 0 == 2 → false (const)
// 编译器：if false { ... } → 整个分支被删除
```

**零开销保证**：不是运行时跳过，是**编译时不存在**。

## 构建模式行为

| 模式 | 构建命令 | 校验行为 | 性能影响 |
|------|---------|---------|---------|
| Release | `go build ./...` | 所有 Assert 返回 `nil` | **零** — 代码不存在 |
| Dev | `go build -tags=dev ./...` | 所有 Assert 返回 `nil` | **零** |
| Debug | `go build -tags=debug ./...` | **执行真正的校验** | 有开销（仅调试用） |

## 使用方式

### SliceMap 内置校验

```go
import "github.com/quant-trading-system/wjboot/v2/pkg/collections"

m := collections.NewSliceMap[string, float64]()

// 追加 100 个价格
for i := 0; i < 100; i++ {
    m.Append("BTC", prices[i])
}

// 校验单个 key: 长度 >= 100
if err := m.AssertMinLen("BTC", 100); err != nil {
    // Debug: 返回 InvariantError
    // Release/Dev: 永远不会进入此分支（编译器消除）
    log.Error("数据增长异常", "err", err)
}

// 校验所有 key: 每个 >= 10
if err := m.AssertAllMinLen(10); err != nil {
    log.Error("存在数据缺失的 key", "err", err)
}
```

### 自定义模块中添加校验

```go
import "github.com/quant-trading-system/wjboot/v2/pkg/buildmode"

func (e *Engine) processBar(bar Bar) {
    // 业务逻辑...
    e.history.Append(bar.Symbol, bar.Close)

    // 仅 debug 构建执行
    if buildmode.IsDebug() {
        if e.history.Len(bar.Symbol) == 0 {
            panic("invariant: history empty after append")
        }
    }
}
```

### 测试中使用

```go
func TestPriceHistoryGrowth(t *testing.T) {
    // 测试始终用 -tags=debug 运行
    // go test -tags=debug ./...
    m := collections.NewSliceMap[string, float64]()

    for i := 0; i < 50; i++ {
        m.Append("ETH", float64(i))
        if err := m.AssertMinLen("ETH", i+1); err != nil {
            t.Fatal(err)
        }
    }
}
```

## 快速参考

| 方法 | 说明 | Debug | Release/Dev |
|------|------|-------|------------|
| `AssertMinLen(key, n)` | 单 key 最小长度校验 | 执行 | `return nil` |
| `AssertAllMinLen(n)` | 全量 key 最小长度校验 | 执行 | `return nil` |
| `buildmode.IsDebug()` | 判断是否 debug 构建 | `true` | `false` (const) |

## 错误类型

```go
// InvariantError 不变量校验失败
type InvariantError struct {
    Key      string  // 出问题的 key
    Expected int     // 期望最小值
    Actual   int     // 实际值
    Kind     string  // "min_len"
}
// 输出: invariant violation [min_len] key=BTC: expected >=100, got 3
```

## 常见错误

| 错误 | 修复 |
|------|------|
| 生产环境运行 `go test -tags=debug` | CI 测试用 debug，生产构建不加 tags |
| 在 Assert 中做重计算 | Assert 内部逻辑要轻量，重计算放 buildmode.IsDebug() 守卫内 |
| 忘了 `-tags=debug` 导致测试校验不生效 | Makefile/CI 配置统一加 `-tags=debug` |

## 扩展：添加自定义校验

在 `pkg/collections/slicemap_invariant.go` 中添加新方法：

```go
func (m *SliceMap[K, V]) AssertNonEmpty(key K) error {
    if !buildmode.IsDebug() {
        return nil
    }
    if m.Len(key) == 0 {
        return &InvariantError{Key: fmt.Sprintf("%v", key), Kind: "non_empty"}
    }
    return nil
}
```
